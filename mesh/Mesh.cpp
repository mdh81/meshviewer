#include "Mesh.h"
#include <limits>
#include <iostream>
#include <fstream>
#include <algorithm>
using namespace std;

namespace meshviewer {

using namespace common;

void Mesh::initialize(const unsigned numVerts, const unsigned numFaces) {
    m_numVertices = numVerts;
    m_numFaces = numFaces;
    m_vertices.reserve(m_numVertices);
    m_faces.reserve(m_numFaces);
}

Mesh::Mesh(const Mesh& another) {
    m_numVertices = another.m_numVertices;
    m_numFaces = another.m_numFaces;
    m_vertices.resize(m_numVertices);
    std::copy(another.m_vertices.cbegin(), another.m_vertices.cend(), m_vertices.begin());
    m_faces.resize(m_numFaces);
    std::copy(another.m_faces.cbegin(), another.m_faces.cend(), m_faces.begin());
}

void Mesh::addVertex(const float x, const float y, const float z) {
    m_vertices.emplace_back(x, y, z);
}

void Mesh::addFace(const initializer_list<unsigned>& vertexIds) {
    m_faces.emplace_back(vertexIds);
    for (auto vertexId : vertexIds) {
        m_vertices.at(vertexId).addFace(m_faces.size()-1);
    }
}

const Vertex& Mesh::getVertex(const unsigned vertexIndex) const {
    if (vertexIndex >= m_numVertices)
        throw std::runtime_error("Vertex index invalid");
    return m_vertices.at(vertexIndex);
} 

const Face& Mesh::getFace(unsigned faceIndex) const {
    if (faceIndex >= m_numFaces)
        throw std::runtime_error("Face index invalid");
    return m_faces.at(faceIndex);
}

const Bounds& Mesh::getBounds() const {
    if (!m_bounds) {
        const_cast<Mesh*>(this)->buildBounds();
    }
    return m_bounds.value();
}

void Mesh::buildBounds() {
    m_bounds.emplace();
    for (auto& v : m_vertices) {
        if (v.x < m_bounds->xmin) m_bounds->xmin = v.x;
        if (v.y < m_bounds->ymin) m_bounds->ymin = v.y;
        if (v.z < m_bounds->zmin) m_bounds->zmin = v.z;

        if (v.x > m_bounds->xmax) m_bounds->xmax = v.x;
        if (v.y > m_bounds->ymax) m_bounds->ymax = v.y;
        if (v.z > m_bounds->zmax) m_bounds->zmax = v.z;
    }
}

void Mesh::removeDuplicateVertices() {
    if (!m_octree) {
        m_octree.emplace(*this);
    }
    for (auto& v : m_vertices) {

    }
}

Vertex Mesh::getCentroid() const {
    if (!m_bounds) {
        getBounds();
    }
    return Vertex { (this->m_bounds->xmax + this->m_bounds->xmin) * 0.5f,
                    (this->m_bounds->ymax + this->m_bounds->ymin) * 0.5f,
                    (this->m_bounds->zmax + this->m_bounds->zmin) * 0.5f };
}

void Mesh::buildVertexData() {
    m_vertexData = VertexData(m_numVertices);
    for (auto& v : m_vertices) {
        m_vertexData->append({v.x, v.y, v.z}); 
    }
}

Mesh::VertexData Mesh::getVertexData() const {
    if (!m_vertexData) const_cast<Mesh*>(this)->buildVertexData();
    return m_vertexData.value();
}

void Mesh::buildConnectivityData() {
    m_connectivityDataSize = 0;
    for (size_t i = 0; i < m_numFaces; ++i) {
        m_connectivityDataSize += (m_faces.at(i).size() * sizeof(unsigned));
    }
    m_connectivity.reset(new unsigned[m_connectivityDataSize]); 
    for (size_t i = 0, offset = 0; i < m_numFaces; ++i) {
        size_t faceDataSize = m_faces.at(i).size() * sizeof(unsigned);
        memcpy(m_connectivity.get() + offset, m_faces.at(i).data(), faceDataSize);
        offset += m_faces.at(i).size();
    }
}

void Mesh::getConnectivityData(size_t& numBytes, unsigned*& pConnData) const {
    // C++ doesn't provide a way out of const cast to support lazy loading that's
    // necessary here. Not all meshes will be rendered and until a mesh is rendered
    // there is no need to get connectivity data out of a mesh like below
    if (!m_connectivity) const_cast<Mesh*>(this)->buildConnectivityData();
    numBytes = m_connectivityDataSize;
    pConnData = m_connectivity.get(); 
}


std::unique_ptr<Mesh> Mesh::transform(glm::mat4 const& transformMatrix) const {
    std::unique_ptr<Mesh> transformedMesh(new Mesh(*this));
    auto& vertices = transformedMesh->getVertices();
    for (auto& vertex : vertices) {
        Vertex& v = const_cast<Vertex&>(vertex);
        glm::vec4 transformedVertex = transformMatrix * glm::vec4(vertex.x, vertex.y, vertex.z, 1.0f);
        v.x = transformedVertex.x;
        v.y = transformedVertex.y;
        v.z = transformedVertex.z;
    }
    return transformedMesh;
}

void Mesh::writeToSTL(std::string const& fileName) const {
    
    ofstream ofs(fileName, ios::binary);
    char header[80] = "STL file generated by MeshViewer. Author Murali Dhanakoti";
    ofs.write(header, 80);
    if (m_faces.size() > numeric_limits<unsigned>::max()) 
        throw "Cannot write to STL. Number of faces in the mesh exceed the maximum tris supported by STL";
    unsigned numTris = static_cast<unsigned>(m_faces.size());
    ofs.write(reinterpret_cast<char*>(&numTris), 4); 
    unsigned short dummy = 0;
    // TODO: Replace with mathlib
    for (auto& face : m_faces) {
        if (face.size() != 3) throw "Cannot write to STL. Mesh is not triangulated";
        auto& A = m_vertices.at(face.at(0));
        auto& B = m_vertices.at(face.at(1));
        auto& C = m_vertices.at(face.at(2));
        glm::vec3 AB {B.x - A.x, B.y - A.y, B.z - A.z}; 
        glm::vec3 AC {C.x - A.x, C.y - A.y, C.z - A.z}; 
        glm::vec3 normal = glm::cross(AC, AB);
        float n[3] = {normal.x, normal.y, normal.z}; 
        ofs.write(reinterpret_cast<const char*>(n), 12); 
        ofs.write(reinterpret_cast<const char*>(&A), 12);
        ofs.write(reinterpret_cast<const char*>(&B), 12);
        ofs.write(reinterpret_cast<const char*>(&C), 12);
        ofs.write(reinterpret_cast<char*>(&dummy), 2);
    } 
    ofs.close();
}

void Mesh::generateVertexNormals() {
    if (m_vertexNormals) return;
    m_vertexNormals = NormalData(m_numVertices);
    for (size_t i = 0; i < m_numVertices; ++i) {
        auto normal = m_vertices.at(i).getNormal(*this);
        m_vertexNormals->append({normal[0], normal[1], normal[2]}); 
    }
}

void Mesh::generateFaceNormals() {
    if (m_faceNormals) return;
    m_faceNormals = NormalData(m_numFaces);
    for (size_t i = 0; i < m_numFaces; ++i) {
        auto normal = m_faces.at(i).getNormal(*this);
        m_faceNormals->append({normal[0], normal[1], normal[2]}); 
    }
}

Mesh::NormalData Mesh::getNormals(const NormalLocation location) const {
    if (location == NormalLocation::Vertex) {
        if (!m_vertexNormals)  
            const_cast<Mesh*>(this)->generateVertexNormals();
        return m_vertexNormals.value();
    } else {
        if (!m_faceNormals)
            const_cast<Mesh*>(this)->generateFaceNormals();
        return m_faceNormals.value();
    }
} 

}
