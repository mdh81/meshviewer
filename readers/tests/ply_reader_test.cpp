#include "gtest/gtest.h"
#include "ReaderFactory.h"
#include "PLYReader.h"
#include "MockMeshFactory.h"
#include "gmock/gmock.h"
#include <memory>
using namespace std;
using namespace mv;
using namespace mv::common;
using namespace mv::readers;

namespace mv::readers {
    class PLYReaderFixture : public ::testing::Test {
    protected:
        struct HeaderInfo {
            bool isBinary;
            bool isLittleEndian;
            unsigned numVertices;
            unsigned numFaces;
        };
        static HeaderInfo testHeaderParsing(std::string const& header) {
            auto plyReader = PLYReader{"", MockMeshFactory{}};
            istringstream iss(header);
            plyReader.readHeader(iss);
            return {plyReader.isBinary, plyReader.isLittleEndian, plyReader.numVertices, plyReader.numFaces};
        }

        void readNonExistentFile() {
            plyReader->getOutput();
        }

        void readData(std::string const& data) {
            istringstream stream(data);
            // Call private method PLYReader::getOutput() and pass the mock mesh
            // NOTE: Without the mock mesh being passed, gmock's EXPECT_ macros won't have an already instantiated
            // object to work with (this is a gmock hard requirement, see the test below for setup)
            plyReader->getOutput(stream, mockMeshPtr);
        }

        Mesh::MeshPointer mockMeshPtr { new MockMesh{} };
        std::unique_ptr<PLYReader> plyReader { new PLYReader{"", MockMeshFactory{}} };
    };

    TEST_F(PLYReaderFixture, ParseHeader) {
        testing::internal::CaptureStdout();
        std::string header =
                "ply\n"
                "format ascii 1.0\n"
                "comment generated by ply_writer\n"
                "element vertex 437645\n"
                "property float x\n"
                "property float y\n"
                "property float z\n"
                "element face 871414\n"
                "property list uchar int vertex_indices\n"
                "end_header";
        auto parsedHeader = testHeaderParsing(header);
        ASSERT_FALSE(parsedHeader.isBinary);
        ASSERT_FALSE(parsedHeader.isLittleEndian);
        ASSERT_EQ(parsedHeader.numVertices, 437645);
        ASSERT_EQ(parsedHeader.numFaces, 871414);
        auto output = testing::internal::GetCapturedStdout();
        ASSERT_EQ(output, "Parsing PLY file with 437645 vertices and 871414 faces\n");
    }

    TEST_F(PLYReaderFixture, NonExistentFile) {
        ASSERT_THROW(
            try {
                readNonExistentFile();
            } catch(exception& ex) { throw; }
        ,runtime_error);
    }

    TEST_F(PLYReaderFixture, ASCIIInput) {
        std::string asciiFile =
                "ply\n"
                "format ascii 1.0\n"
                "element vertex 3\n"
                "property float x\n"
                "property float y\n"
                "property float z\n"
                "element face 1\n"
                "property list uchar int vertex_indices\n"
                "end_header\n"
                "0 0 0\n"
                "5 0 0\n"
                "5 5 0\n"
                "3 0 1 2";

        auto &mockMesh = dynamic_cast<MockMesh &>(*mockMeshPtr.get());
        EXPECT_CALL(mockMesh, addVertex(0, 0, 0)).Times(testing::Exactly(1));
        EXPECT_CALL(mockMesh, addVertex(5, 0, 0)).Times(testing::Exactly(1));
        EXPECT_CALL(mockMesh, addVertex(5, 5, 0)).Times(testing::Exactly(1));

        readData(asciiFile);
    }

}